Q ： 塔子哥是一个富有的商人，他在一家大型贸易公司工作。他的公司位于城市的中心区，是一座高耸的摩天大楼。他住在郊区的别墅，是一座豪华的欧式建筑。他每天都要开车上下班，穿越城市的繁华和拥堵。不幸的是，这个城市为了缓解交通拥堵，实行了限行规则，每天都有一些车牌号的最后一位数字被禁止上路。塔子哥不想因为限行而迟到或者请假，因为他的工作很重要，涉及到很多国际贸易的合同和谈判。
     所以他想买几辆车，让他每天都有车可以用。假设他不能换车牌号，也不能选择其他交通方式，而且他的工作时间是固定的，问他至少需要买多少辆车？如果没有办法做到，就输出 -1。

A:          bit = [0] * 7
            for i in range(7):
                lst = list(map(int, input().split()))
                for j in range(1, len(lst)):
                    # 先将第 i 天限行的每个尾号用二进制记录下来
                    # 1<< lst[i] 是指把1移动到指定位置
                    # 如果 lst[i] =3 则为 1000
                    # |= 或运算  
                    bit[i] |= 1 << lst[j]
                # 通过 1111 1111 11 这个二进制表示全部尾号，减去限行的尾号，就是第 i 天不限行的尾号表示
                bit[i] = 1023 - bit[i]
            
            ans = -1
            
            # 枚举所有可能拥有的尾号表示
            for i in range(1, 1024):
                cnt = 0    
                for j in range(10):
                    # 整体上，这个表达式的目的是检查数字i的第j位是0还是1。
                    #  如果i的第j位是1，那么整个表达式的结果将是1，否则结果将是0
                    if i >> j & 1:
                        cnt += 1
                # 判断拥有的尾号与 7 天每天的不限行尾号是否有交集
                # 如果都有交集就说明这个尾号表示是合法的
                # 如果存在至少 1 天与这个尾号表示无交集，就说明这个尾号表示是不合法的
                
                ok = True
                for j in range(7):
                    if (bit[j] & i) == 0:
                        ok = False
                        break
                # 如果合法，取最少的尾号数量
                if ok:
                    if ans == -1:
                        ans = cnt
                    else:
                        ans = min(ans, cnt)
            
            print(ans)
